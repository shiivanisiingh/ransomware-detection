<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bitcoin Heist Predictive Model</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      line-height: 1.6;
      margin: 20px;
    }
    pre {
      background: #f4f4f4;
      padding: 10px;
      border: 1px solid #ddd;
      overflow-x: auto;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
    }
    table, th, td {
      border: 1px solid #ddd;
      padding: 8px;
    }
    th {
      background-color: #f2f2f2;
      text-align: left;
    }
    .highlight {
      background-color: #e7f3fe;
      border-left: 4px solid #2196F3;
      padding: 10px;
    }
  </style>
</head>
<body>
  <h1>Bitcoin Heist Predictive Model</h1>

  <div class="highlight">
    <p>This project aims to build a predictive model for identifying ransomware families from Bitcoin Heist data. The decisions made in the code below are tailored for a business scenario involving a cryptocurrency exchange company that aims to identify suspicious accounts associated with ransomware attacks. Early detection helps the company prevent fraudulent activities and protect legitimate users.</p>
  </div>

  <h2>Python Code</h2>
  <pre>
# Import required libraries
import pandas as pd
import numpy as np
from sklearn.impute import SimpleImputer
from sklearn.preprocessing import StandardScaler
from sklearn.feature_selection import VarianceThreshold
from sklearn.linear_model import LogisticRegression
from sklearn.model_selection import StratifiedKFold
from imblearn.over_sampling import SMOTE
from sklearn.exceptions import ConvergenceWarning
from sklearn.calibration import CalibratedClassifierCV
import warnings

# Suppress convergence warnings
warnings.filterwarnings("ignore", category=ConvergenceWarning)

# Step 1: Load Data & Verify Class Distribution
data = pd.read_csv('/content/drive/MyDrive/ML/Dataset/BitcoinHeistData.csv')
print("Raw Label Distribution:")
print(data['label'].value_counts())

# Step 2: Binary Label Conversion
data['label'] = np.where(data['label'] == 'white', 0, 1)
y = data['label'].astype(int)
print("\nBinary Class Distribution:")
print(pd.Series(y).value_counts())

# Step 3: Data Preprocessing
X = data.drop(columns=['label', 'address'])
imputer = SimpleImputer(strategy='median')
X_imputed = imputer.fit_transform(X)
selector = VarianceThreshold(threshold=0)
X_filtered = selector.fit_transform(X_imputed)
X_filtered[:, 0] = np.log1p(X_filtered[:, 0])
scaler = StandardScaler()
X_processed = scaler.fit_transform(X_filtered)

# Step 4: Handle Class Imbalance with SMOTE
minority_ratio = y.sum() / len(y)
if minority_ratio < 0.05:
    smote = SMOTE(sampling_strategy=0.5, random_state=1)
    X_resampled, y_resampled = smote.fit_resample(X_processed, y)
else:
    X_resampled, y_resampled = X_processed.copy(), y.copy()

# Step 5: Stratified Cross-Validation Setup
skf = StratifiedKFold(n_splits=10, shuffle=True, random_state=1)
fold_vec = np.zeros(len(y_resampled), dtype=int)
for fold_num, (_, test_idx) in enumerate(skf.split(X_resampled, y_resampled)):
    fold_vec[test_idx] = fold_num + 1

# Step 6: Threshold Optimization with Cost Calculation
def calculate_cost(y_actual, y_pred):
    FP = np.sum((y_pred == 1) & (y_actual == 0))
    FN = np.sum((y_pred == 0) & (y_actual == 1))
    return 100 * FP + 1000 * FN

thresholds = np.linspace(0.01, 0.99, 100)
out = np.zeros((100, 10))
for i in range(10):
    test_mask = (fold_vec == i+1)
    X_train, X_test = X_resampled[~test_mask], X_resampled[test_mask]
    y_train, y_test = y_resampled[~test_mask], y_resampled[test_mask]

    if len(np.unique(y_train)) < 2:
        continue

    model = CalibratedClassifierCV(LogisticRegression(), method='sigmoid')
    model.fit(X_train, y_train)
    proba = model.predict_proba(X_test)[:, 1]

    for j in range(100):
        pred = (proba >= thresholds[j]).astype(int)
        out[j, i] = calculate_cost(y_test, pred)

mean_costs = np.nanmean(out, axis=1)
best_idx = np.nanargmin(mean_costs)
best_threshold = thresholds[best_idx]
print(f"\nOptimal Threshold: {best_threshold:.3f}")
print(f"Associated Cost: ${mean_costs[best_idx]:,.2f}")
  </pre>

  <h2>Business Scenario and Error Analysis</h2>
  <p>We consider a cryptocurrency exchange aiming to prevent transactions associated with ransomware. The predictions identify potentially harmful accounts.</p>

  <h3>Error Analysis</h3>
  <table>
    <tr>
      <th>Error Type</th>
      <th>Definition</th>
      <th>Real-World Impact</th>
      <th>Cost Ratio</th>
    </tr>
    <tr>
      <td>False Positive</td>
      <td>An innocent account flagged as ransomware.</td>
      <td>Inconvenience to legitimate users, potential reputation loss.</td>
      <td>1</td>
    </tr>
    <tr>
      <td>False Negative</td>
      <td>A ransomware account not flagged.</td>
      <td>Continued ransomware activity, financial and reputational damage.</td>
      <td>10</td>
    </tr>
  </table>

  <h2>Key Decisions and Justifications</h2>
  <ul>
    <li><strong>Binary Label Conversion:</strong> Simplifies classification task into identifying ransomware vs. non-ransomware.</li>
    <li><strong>SMOTE:</strong> Addresses class imbalance by oversampling the minority class.</li>
    <li><strong>Custom Cost Function:</strong> Weighted cost of false negatives and false positives aligns with business priorities.</li>
    <li><strong>Threshold Optimization:</strong> Ensures the model minimizes total cost for the business.</li>
  </ul>
</body>
</html>
